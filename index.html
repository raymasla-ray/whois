<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èª°æ˜¯è‡¥åº•</title>
    <style>
        :root {
            /* é…è‰²å‡ç´šï¼šç¾ä»£ç°¡ç´„æ·±è‰²é¢¨æ ¼ (Modern Dark Premium) */
            --primary: #4f46e5;       /* Indigo */
            --primary-hover: #4338ca;
            --danger: #e11d48;        /* Rose */
            --success: #059669;       /* Emerald */
            --warning: #d97706;       /* Amber */
            
            /* èƒŒæ™¯æ¼¸å±¤ï¼šæ·±å²©ç°è‡³åˆå¤œè— */
            --bg-grad-1: #0f172a;     /* Slate 900 */
            --bg-grad-2: #1e293b;     /* Slate 800 */
            --bg-grad-3: #172554;     /* Blue 950 */
            
            /* ç»ç’ƒæ“¬æ…‹è®Šæ•¸ */
            --glass-bg: rgba(30, 41, 59, 0.7); 
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
            
            --text: #f8fafc;          /* Slate 50 */
            --text-muted: #94a3b8;    /* Slate 400 */
            
            --card-bg: rgba(255, 255, 255, 0.03);
            --input-bg: rgba(15, 23, 42, 0.6);
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.9); }
            60% { transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes subtle-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.01); }
            100% { transform: scale(1); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-grad-1), var(--bg-grad-2), var(--bg-grad-3));
            background-size: 200% 200%;
            animation: gradientBG 20s ease infinite;
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }

        .container {
            width: 100%;
            max-width: 500px;
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            padding: 30px;
            border-radius: 24px;
            box-shadow: var(--glass-shadow);
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            max-height: 92vh;
            overflow-y: auto;
            transition: height 0.3s ease;
        }

        h1, h2, h3 { 
            text-align: center; 
            color: var(--text); 
            margin-top: 0; 
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }

        .screen { display: none; }
        .screen.active { 
            display: block; 
            animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        button {
            width: 100%;
            padding: 14px;
            background: var(--primary);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            font-size: 15px;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.2s ease;
            font-weight: 600;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        button:hover { 
            background: var(--primary-hover);
            transform: translateY(-1px); 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        button:active { transform: translateY(0); opacity: 0.9; }
        button:disabled { background: #334155; cursor: not-allowed; color: #64748b; border-color: transparent; box-shadow: none; }
        
        button.danger { background: var(--danger); }
        button.danger:hover { background: #be123c; }
        
        button.secondary { background: #334155; color: #e2e8f0; }
        button.secondary:hover { background: #475569; }
        
        button.success { background: var(--success); }
        button.success:hover { background: #047857; }
        
        button.small-btn { width: auto; padding: 8px 16px; font-size: 13px; margin: 0; border-radius: 8px; }
        
        input, select {
            width: 100%;
            padding: 14px;
            margin: 10px 0;
            background: var(--input-bg);
            border: 1px solid var(--glass-border);
            color: var(--text);
            border-radius: 12px;
            box-sizing: border-box;
            font-size: 16px;
            transition: 0.2s;
        }
        input:focus, select:focus { 
            border-color: var(--primary); 
            outline: none; 
            background: rgba(15, 23, 42, 0.8);
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        input::placeholder { color: #475569; }

        .room-item, .player-card {
            background: var(--card-bg);
            border: 1px solid var(--glass-border);
            padding: 16px;
            margin-bottom: 10px;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        #player-list .player-card, #room-list .room-item {
            animation: fadeInUp 0.4s ease forwards;
        }
        #player-list .player-card:nth-child(1) { animation-delay: 0.05s; }
        #player-list .player-card:nth-child(2) { animation-delay: 0.1s; }
        #player-list .player-card:nth-child(3) { animation-delay: 0.15s; }
        #player-list .player-card:nth-child(4) { animation-delay: 0.2s; }
        #player-list .player-card:nth-child(5) { animation-delay: 0.25s; }

        .room-item:hover, .player-card:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        .player-card.is-me { 
            border: 1px solid var(--primary); 
            background: rgba(79, 70, 229, 0.1);
        }
        .player-card.dead { 
            opacity: 0.5; 
            background: rgba(0, 0, 0, 0.2); 
        }
        .player-card.dead strong { text-decoration: line-through; color: var(--danger); }

        .word-display {
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            padding: 30px;
            text-align: center;
            font-size: 28px;
            font-weight: 700;
            border-radius: 16px;
            margin: 25px 0;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.1);
            user-select: none;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .word-display.hidden {
            background: repeating-linear-gradient(
                45deg,
                #1e293b,
                #1e293b 10px,
                #0f172a 10px,
                #0f172a 20px
            );
            color: transparent;
        }
        .word-display.hidden::after {
            content: "é»æ“ŠæŸ¥çœ‹èº«åˆ†";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #94a3b8;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            background: rgba(15, 23, 42, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
        }
        .word-display.hidden #my-word { opacity: 0; }
        
        .word-display.revealed {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            color: white;
            animation: subtle-pulse 3s infinite;
        }
        
        .word-display:active { transform: scale(0.98); }

        .tag {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 6px;
            background: #334155;
            color: #cbd5e1;
            margin-left: 8px;
            vertical-align: middle;
            font-weight: 500;
        }
        .tag.host { background: var(--warning); color: #fff; }
        .tag.vote-count { background: var(--danger); color: white; }
        .tag.score { background: rgba(79, 70, 229, 0.2); color: #818cf8; border: 1px solid rgba(79, 70, 229, 0.3); }

        .vote-btn {
            background: var(--danger);
            width: auto;
            padding: 6px 14px;
            font-size: 12px;
            margin: 0;
            border-radius: 20px;
            box-shadow: none;
            border: none;
        }
        .vote-btn:hover { background: #be123c; transform: none; }

        #custom-words-area {
            display: none;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 12px;
            border: 1px dashed #475569;
            margin-top: 15px;
            animation: fadeInUp 0.3s;
        }
        .custom-word-item {
            display: flex;
            justify-content: space-between;
            background: rgba(255,255,255,0.05);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 6px;
            font-size: 14px;
        }

        #overlay-result {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(5px);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
            animation: fadeIn 0.2s;
        }
        
        .result-container {
            animation: popIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            background: #1e293b;
            padding: 40px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            width: 85%;
            max-width: 350px;
        }

        .result-title { font-size: 14px; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;}
        .result-name { font-size: 36px; font-weight: 800; color: white; margin: 10px 0; }
        .result-role { font-size: 24px; margin-bottom: 25px; font-weight: 600; }
        .result-role.spy { color: var(--danger); }
        .result-role.civilian { color: var(--success); }
        
        .result-status { 
            font-size: 18px; 
            border: 1px solid #475569; 
            padding: 8px 24px; 
            border-radius: 50px; 
            margin-top: 20px; 
            display: inline-block;
            background: #0f172a;
            color: #cbd5e1;
        }
        
        .admin-nuke-btn {
            background: transparent;
            border: 1px solid #64748b;
            color: #94a3b8;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 5px;
            border-radius: 4px;
        }
        .admin-nuke-btn:hover { background: var(--danger); color: white; border-color: var(--danger); }
        
        .identity-reveal {
            font-size: 12px;
            font-family: monospace;
            margin-top: 6px;
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            display: table;
            border-left-width: 3px;
            border-left-style: solid;
        }

        #chat-section {
            margin-top: 25px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 20px;
            display: flex;
            flex-direction: column;
            height: 280px; 
        }
        #chat-messages {
            flex: 1;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 16px;
            padding: 15px;
            overflow-y: auto;
            margin-bottom: 12px;
            border: 1px solid rgba(255,255,255,0.05);
            font-size: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .chat-msg { 
            max-width: 80%;
            padding: 10px 14px;
            border-radius: 16px;
            line-height: 1.5;
            word-break: break-all;
            position: relative;
            animation: fadeInUp 0.2s;
            font-size: 14px;
            background: #334155;
            color: #f1f5f9;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .chat-msg.is-me {
            align-self: flex-end;
            background: var(--primary);
            color: white;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 4px;
        }

        .chat-sender { 
            display: block;
            font-size: 11px;
            color: #94a3b8; 
            margin-bottom: 2px;
        }
        .chat-msg.is-me .chat-sender { color: rgba(255,255,255,0.7); text-align: right;}
        
        .chat-input-wrapper { display: flex; gap: 10px; }
        .chat-input-wrapper input { margin: 0; flex: 1; background: rgba(15, 23, 42, 0.6); border-radius: 20px; padding: 12px 18px;}
        .chat-input-wrapper button { width: auto; margin: 0; padding: 0 20px; border-radius: 20px; background: var(--primary); }

    </style>
</head>
<body>

<div id="overlay-result">
    <div class="result-container">
        <div class="result-title">æœ¬è¼ªæŠ•ç¥¨çµæœ</div>
        <div id="res-name" class="result-name">???</div>
        <div id="res-role" class="result-role">èº«åˆ†ï¼š<span id="res-role-text">---</span></div>
        
        <div id="res-game-status" class="result-status">éŠæˆ²ç¹¼çºŒ</div>

        <div style="margin-top: 40px; width: 100%;">
            <button onclick="app.closeOverlay()" class="secondary">é—œé–‰</button>
        </div>
    </div>
</div>

<div class="container">
    <div id="screen-login" class="screen active">
        <h1>ğŸ•µï¸ èª°æ˜¯è‡¥åº•</h1>
        <p style="text-align:center; color:var(--text-muted); margin-bottom:30px; font-size:14px;">æ­¡è¿èª°æ˜¯è‡¥åº•ï¼åœ¨ä¸‹æ–¹è¼¸å…¥æš±ç¨±é–‹å§‹éŠæˆ²ï¼</p>
        <input type="text" id="username" placeholder="è«‹è¼¸å…¥ä½ çš„æš±ç¨±..." autocomplete="off">
        <button onclick="app.login()">é€²å…¥å¤§å»³</button>
    </div>

    <div id="screen-lobby" class="screen">
        <h2>éŠæˆ²å¤§å»³</h2>
        <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; background:rgba(255,255,255,0.05); padding:12px; border-radius:12px;">
            <span>ç©å®¶: <span id="display-name" style="font-weight:600; color:var(--text);"></span></span>
            <button class="success small-btn" onclick="app.showCreateRoom()">+ å‰µå»ºæˆ¿é–“</button>
        </div>
        <h3 style="text-align:left; font-size:14px; color:var(--text-muted); border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px; margin-bottom:15px;">æˆ¿é–“åˆ—è¡¨</h3>
        <div id="room-list">
            <div style="text-align:center; padding:20px; color:var(--text-muted);">æ­£åœ¨é€£æ¥ä¼ºæœå™¨...</div>
        </div>
    </div>

    <div id="screen-create" class="screen">
        <h2>å‰µå»ºæ–°æˆ¿é–“</h2>
        
        <label>æˆ¿é–“åç¨±</label>
        <input type="text" id="room-name-input" placeholder="ä¾‹å¦‚ï¼šå¯ç–‘çš„æˆ¿é–“" value="ä¾†ç•¶è‡¥åº•å›‰">

        <label>è‡¥åº•äººæ•¸</label>
        <select id="spy-count">
            <option value="1">1äºº</option>
            <option value="2">2äºº</option>
            <option value="3">3äºº</option>
        </select>

        <div style="margin-top: 15px; margin-bottom: 5px;">
            <label style="margin-bottom:5px; display:block;">ç²å‹ç©åˆ†è¨­å®š</label>
            <div style="display:flex; gap:10px;">
                <div style="flex:1;">
                    <span style="font-size:12px; color:var(--text-muted);">å¹³æ°‘ç²å‹ (+åˆ†)</span>
                    <input type="number" id="score-civ" value="1" placeholder="1">
                </div>
                <div style="flex:1;">
                    <span style="font-size:12px; color:var(--text-muted);">è‡¥åº•ç²å‹ (+åˆ†)</span>
                    <input type="number" id="score-spy" value="2" placeholder="2">
                </div>
            </div>
        </div>

        <div style="margin-top: 15px; margin-bottom: 5px;">
            <label style="margin-bottom:5px; display:block;">å‡ºé¡Œæ¨¡å¼</label>
            <select id="word-mode">
                <option value="random">éš¨æ©Ÿå‡ºé¡Œ</option>
                <option value="sequential">æŒ‰é †åºå‡ºé¡Œ (å¾ªç’°)</option>
            </select>
        </div>

        <div style="margin: 20px 0;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label style="margin:0;">è©èªè¨­å®š</label>
                <button class="secondary small-btn" type="button" onclick="app.toggleCustomWords()">+ è‡ªè¨‚è©èª</button>
            </div>
            
            <div id="custom-words-area">
                <p style="margin:0 0 10px 0; font-size:12px; color:var(--text-muted);">è¼¸å…¥å¾Œé»æ“Šã€Œæ–°å¢ã€ã€‚è‹¥æœ‰æ–°å¢ï¼ŒéŠæˆ²å°‡åªä½¿ç”¨æ­¤åˆ—è¡¨ã€‚</p>
                <div style="display:flex; gap:10px;">
                    <input type="text" id="custom-civ" placeholder="å¹³æ°‘è© (å¦‚: è˜‹æœ)" style="margin:0;">
                    <input type="text" id="custom-spy" placeholder="è‡¥åº•è© (å¦‚: é¦™è•‰)" style="margin:0;">
                </div>
                <button type="button" class="success small-btn" style="width:100%; margin-top:10px;" onclick="app.addCustomWord()">æ–°å¢è©çµ„</button>
                
                <div id="custom-words-list" style="margin-top:10px; max-height:100px; overflow-y:auto;">
                    </div>
            </div>
        </div>

        <div style="display:flex; gap:10px;">
            <button class="secondary" onclick="app.switchScreen('screen-lobby')">å–æ¶ˆ</button>
            <button onclick="app.createRoom()">ç¢ºèªå‰µå»º</button>
        </div>
    </div>

    <div id="screen-room" class="screen">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
            <div style="display:flex; flex-direction:column;">
                <strong id="room-name-display" style="font-size: 18px; color: var(--text);">æˆ¿é–“åç¨±</strong>
                <span id="room-id-display" style="font-size: 12px; color: var(--text-muted); font-family:monospace;">ID: ----</span>
            </div>
            <button class="secondary small-btn" onclick="app.leaveRoom()">
                é›¢é–‹
            </button>
        </div>

        <div id="game-area" style="display:none;">
            <div class="word-display hidden" id="word-card">
                <div style="font-size:12px; opacity:0.7; margin-bottom:5px; text-transform: uppercase; letter-spacing:1px;">ä½ çš„è©èª</div>
                <span id="my-word">???</span>
            </div>
            <p style="text-align:center; font-size:12px; color:var(--text-muted); margin-top:-15px; margin-bottom: 20px;">
                ğŸ‘† é»æ“Šå¡ç‰‡ æŸ¥çœ‹/éš±è— ä½ çš„è©èª
            </p>
        </div>

        <div style="display:flex; justify-content: space-between; align-items: flex-end; margin-bottom: 10px;">
            <h3 style="margin:0; font-size:15px; color:var(--text-muted);">ç©å®¶åˆ—è¡¨ (<span id="player-count">0</span>äºº)</h3>
            <span id="status-badge" class="tag" style="font-size:12px; padding: 4px 10px;">ç­‰å¾…ä¸­</span>
        </div>
        
        <div id="player-list"></div>

        <div id="host-controls" style="display:none; border-top: 1px dashed rgba(255,255,255,0.15); padding-top:20px; margin-top:20px;">
            <p style="text-align:center; color:var(--warning); font-size:11px; margin:0 0 10px 0; letter-spacing:1px; font-weight:600;">HOST CONTROLS</p>
            
            <button onclick="app.startGame()" id="btn-start" class="success">ğŸš€ é–‹å§‹éŠæˆ²</button>
            
            <div id="ingame-controls" style="display:none;">
                <button onclick="app.startVoting()" id="btn-start-vote">ğŸ“¢ é–‹å§‹æŠ•ç¥¨</button>
                <button onclick="app.endVoting()" id="btn-end-vote" class="danger" style="display:none;">ğŸ›‘ çµæŸæŠ•ç¥¨ä¸¦æ­æ›‰</button>
            </div>

            <button onclick="app.nextRound()" id="btn-restart" style="display:none;">ğŸ”„ ä¸‹ä¸€å±€ (æ›è©)</button>
            
            <button class="danger small-btn" onclick="app.deleteRoom()" style="margin-top:20px; background: transparent; border:1px solid var(--danger); color: var(--danger); opacity:0.7;">
                âš ï¸ è§£æ•£æˆ¿é–“
            </button>
        </div>

        <div id="chat-section">
            <div id="chat-messages">
                <div style="color:var(--text-muted); font-style:italic; text-align:center; padding:20px;">-- èŠå¤©å®¤å·²é€£æ¥ --</div>
            </div>
            <div class="chat-input-wrapper">
                <input type="text" id="chat-input" placeholder="è¼¸å…¥è¨Šæ¯..." autocomplete="off">
                <button onclick="app.sendChat()" class="small-btn">â¤</button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, push, onValue, update, remove, onDisconnect, get, child, onChildAdded } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

    // --- 1. é…ç½®èˆ‡åˆå§‹åŒ– (ä¿æŒåŸæ¨£) ---
    const firebaseConfig = {
        apiKey: "AIzaSyC7PZLTTNf17cfp9gCHudWiWX8SYPSCdDI",
        authDomain: "onlineeasyraygame.firebaseapp.com",
        databaseURL: "https://onlineeasyraygame-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "onlineeasyraygame",
        storageBucket: "onlineeasyraygame.firebasestorage.app",
        messagingSenderId: "622138442346",
        appId: "1:622138442346:web:02745ec52f0e83ad428013",
        measurementId: "G-PZB26XW21J"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --- 2. æ–°è©èªåº« (å·²æ›´æ–°) ---
    const rawWords = `
åª½åª½â€”â€”çˆ¸çˆ¸
è£œç¿’ç­â€”â€”å®‰è¦ªç­
è€³æ©Ÿâ€”â€”å–‡å­
å£“æ­²éŒ¢â€”â€”é›¶ç”¨éŒ¢
çµ¦è€å¸«çš„ä¿¡â€”â€”æƒ…æ›¸
æ­»äº¡ç­†è¨˜æœ¬â€”â€”æ—¥è¨˜
è¦ç´…åŒ…â€”â€”æ¶åŠ«
åœ¨åºŠä¸Šç¡è¦ºâ€”â€”ä¸Šèª²å·ç¡è¦º
å®ˆæ­²â€”â€”ç†¬å¤œ
æ‰“éº»å°‡â€”â€”ç©æ’²å…‹ç‰Œ
è¦ç´…åŒ…â€”â€”æ‰¾äººè¨å‚µ
é­ç‚®â€”â€”ç…™ç«
æ°´é¤ƒâ€”â€”æ··æ²Œ
ç´…åŒ…â€”â€”éŒ¢åŒ…
10$â€”â€”åè¬$
ä¿¡ç”¨å¡â€”â€”æ·é‹å¡
é›»è©±äº­â€”â€”é›»ç«¶æ‰‹æ©Ÿ
è¡Œå‹•å……é›»å™¨â€”â€”æ’åº§
å­¸æ ¡è£¡â€”â€”åœ¨å®¶
    `;

    // è§£ææ–°æ ¼å¼ (WordAâ€”â€”WordB)
    const wordPairs = rawWords.trim().split('\n').map(line => {
        const parts = line.split(/â€”â€”/);
        if(parts.length >= 2) return [parts[0].trim(), parts[1].trim()];
        return null;
    }).filter(p => p !== null && p[0] && p[1]);

    // --- 3. éŠæˆ²é‚è¼¯èˆ‡å…¨åŸŸè®Šæ•¸ ---
    window.gameState = {
        user: { name: "", id: "" },
        currentRoomId: null,
        isHost: false,
        wordVisible: false,
        localVoteTarget: null,
        isAdmin: false,
        tempCustomWords: [], // æš«å­˜è‡ªè¨‚è©èª
        chatListener: null 
    };

    const generateId = () => Math.random().toString(36).substr(2, 9);

    window.app = {
        login: () => {
            const name = document.getElementById('username').value.trim();
            if (!name) return alert("è«‹è¼¸å…¥æš±ç¨±ï¼");
            gameState.user.name = name;
            
            if (name === "araygame") {
                gameState.isAdmin = true;
            }

            gameState.user.id = generateId();
            
            document.getElementById('display-name').innerText = name;
            window.app.switchScreen('screen-lobby');
            
            const roomsRef = ref(db, 'whois_room');
            onValue(roomsRef, (snapshot) => {
                const rooms = snapshot.val();
                renderRoomList(rooms);
            });
        },

        switchScreen: (screenId) => {
            document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        },

        showCreateRoom: () => {
            // é‡ç½®è‡ªè¨‚è©èªèˆ‡æˆ¿é–“åç¨±
            gameState.tempCustomWords = [];
            document.getElementById('custom-words-list').innerHTML = '';
            document.getElementById('custom-words-area').style.display = 'none';
            document.getElementById('custom-civ').value = '';
            document.getElementById('custom-spy').value = '';
            document.getElementById('room-name-input').value = "ä¾†ç•¶è‡¥åº•å›‰"; 
            document.getElementById('score-civ').value = 1;
            document.getElementById('score-spy').value = 2;
            document.getElementById('word-mode').value = 'random'; // é‡ç½®ç‚ºéš¨æ©Ÿ
            window.app.switchScreen('screen-create');
        },

        toggleCustomWords: () => {
            const area = document.getElementById('custom-words-area');
            area.style.display = area.style.display === 'none' ? 'block' : 'none';
        },

        addCustomWord: () => {
            const civ = document.getElementById('custom-civ').value.trim();
            const spy = document.getElementById('custom-spy').value.trim();
            
            if (!civ || !spy) return alert("è«‹è¼¸å…¥å®Œæ•´çš„å¹³æ°‘è©å’Œè‡¥åº•è©");
            
            gameState.tempCustomWords.push([civ, spy]);
            
            // æ›´æ–° UI
            const div = document.createElement('div');
            div.className = 'custom-word-item';
            div.innerHTML = `<span>${civ} â€”â€” ${spy}</span>`;
            document.getElementById('custom-words-list').appendChild(div);
            
            document.getElementById('custom-civ').value = '';
            document.getElementById('custom-spy').value = '';
        },

        createRoom: async () => {
            const maxPlayers = 999; 
            const spyCount = parseInt(document.getElementById('spy-count').value);
            const roomName = document.getElementById('room-name-input').value.trim() || "æœªå‘½åæˆ¿é–“"; 
            
            // è®€å–åˆ†æ•¸è¨­å®š
            const civScore = parseInt(document.getElementById('score-civ').value) || 10;
            const spyScore = parseInt(document.getElementById('score-spy').value) || 20;
            
            // è®€å–é †åºè¨­å®š
            const wordMode = document.getElementById('word-mode').value;

            if (spyCount < 1) return alert("è‡¥åº•è‡³å°‘è¦æœ‰ä¸€äºº");

            const roomId = Math.floor(1000 + Math.random() * 9000).toString();
            gameState.currentRoomId = roomId;
            gameState.isHost = true;

            const roomRef = ref(db, 'whois_room/' + roomId);
            await set(roomRef, {
                config: { 
                    roomName, 
                    maxPlayers, 
                    spyCount,
                    customWords: gameState.tempCustomWords,
                    scoreSettings: { 
                        civ: civScore,
                        spy: spyScore
                    },
                    wordMode: wordMode, // 'random' or 'sequential'
                    currentWordIndex: 0 // ç”¨æ–¼é †åºæ¨¡å¼çš„è¨ˆæ•¸å™¨
                },
                status: 'waiting', 
                players: {
                    [gameState.user.id]: {
                        name: gameState.user.name,
                        isHost: true,
                        status: 'alive',
                        votes: 0,
                        score: 0, 
                        voteTarget: null
                    }
                },
                result: null,
                createdAt: Date.now()
            });

            onDisconnect(ref(db, `whois_room/${roomId}/players/${gameState.user.id}`)).remove();
            enterRoom(roomId);
        },

        deleteRoom: async () => {
             if(!confirm("ç¢ºå®šè¦è§£æ•£æˆ¿é–“å—ï¼Ÿ")) return;
             await remove(ref(db, `whois_room/${gameState.currentRoomId}`));
             window.app.leaveRoom();
        },

        adminForceDelete: async (targetRoomId) => {
            if(!confirm(`[ç®¡ç†å“¡] ç¢ºå®šå¼·åˆ¶è§£æ•£æˆ¿é–“ ${targetRoomId}ï¼Ÿ`)) return;
            await remove(ref(db, `whois_room/${targetRoomId}`));
        },

        joinRoom: async (roomId) => {
            const roomRef = ref(db, `whois_room/${roomId}`);
            gameState.currentRoomId = roomId;
            gameState.isHost = false;

            const playerRef = ref(db, `whois_room/${roomId}/players/${gameState.user.id}`);
            await set(playerRef, {
                name: gameState.user.name,
                isHost: false,
                status: 'alive',
                votes: 0,
                score: 0, 
                voteTarget: null
            });
            
            onDisconnect(playerRef).remove();
            enterRoom(roomId);
        },

        leaveRoom: async () => {
            if(gameState.currentRoomId) {
                const playerRef = ref(db, `whois_room/${gameState.currentRoomId}/players/${gameState.user.id}`);
                await remove(playerRef);
            }
            gameState.currentRoomId = null;
            gameState.isHost = false;
            
            if (gameState.chatListener) {
                gameState.chatListener = null;
            }

            window.app.switchScreen('screen-lobby');
        },

        // --- èŠå¤©å®¤åŠŸèƒ½ ---
        sendChat: () => {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (!text) return;
            
            const roomId = gameState.currentRoomId;
            const messagesRef = ref(db, `whois_room/${roomId}/messages`);
            
            push(messagesRef, {
                sender: gameState.user.name,
                text: text,
                timestamp: Date.now()
            });
            
            input.value = '';
        },

        startGame: async () => {
            const roomId = gameState.currentRoomId;
            
            const roomSnapshot = await get(child(ref(db), `whois_room/${roomId}`));
            const roomData = roomSnapshot.val();
            
            // æª¢æŸ¥äººæ•¸æ˜¯å¦è¶³å¤ 
            const playerCount = Object.keys(roomData.players || {}).length;
            if (playerCount <= roomData.config.spyCount + 1) {
                alert(`äººæ•¸ä¸è¶³ï¼ç›®å‰ ${playerCount} äººï¼Œè‡¥åº•è¨­å®š ${roomData.config.spyCount} äººã€‚è‡³å°‘éœ€è¦ ${roomData.config.spyCount + 2} äººæ‰èƒ½é–‹å§‹ã€‚`);
                return;
            }

            let currentPool = wordPairs; 
            if (roomData.config && roomData.config.customWords && roomData.config.customWords.length > 0) {
                currentPool = roomData.config.customWords;
            }

            // --- ä¿®æ”¹ï¼šæ ¹æ“šæ¨¡å¼é¸æ“‡è©èª ---
            let pair;
            const mode = roomData.config.wordMode || 'random';
            
            // è®€å–ç•¶å‰ç´¢å¼• (å¦‚æœæ²’æœ‰å‰‡ç‚º 0)
            let currentIndex = roomData.config.currentWordIndex || 0;
            let nextIndex = currentIndex;

            if (mode === 'sequential') {
                // ç¢ºä¿ç´¢å¼•ä¸è¶…å‡ºç¯„åœ
                if (currentIndex >= currentPool.length) currentIndex = 0;
                
                pair = currentPool[currentIndex];
                
                // è¨­å®šä¸‹ä¸€å±€çš„ç´¢å¼• (å¾ªç’°)
                nextIndex = (currentIndex + 1) % currentPool.length;
            } else {
                // éš¨æ©Ÿæ¨¡å¼
                pair = currentPool[Math.floor(Math.random() * currentPool.length)];
            }
            // -----------------------------
            
            if (!pair) {
                alert("è©åº«ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡è©¦");
                return;
            }

            const flip = Math.random() > 0.5;
            const civilianWord = flip ? pair[0] : pair[1];
            const spyWord = flip ? pair[1] : pair[0];

            // æ›´æ–°éŠæˆ²ç‹€æ…‹ï¼ŒåŒæ™‚æ›´æ–° currentWordIndex ä»¥å‚™ä¸‹ä¸€å±€ä½¿ç”¨
            const updates = {};
            updates[`whois_room/${roomId}/status`] = 'processing';
            updates[`whois_room/${roomId}/words`] = { civilian: civilianWord, spy: spyWord };
            updates[`whois_room/${roomId}/result`] = null;
            updates[`whois_room/${roomId}/config/currentWordIndex`] = nextIndex;

            update(ref(db), updates);
        },

        startVoting: async () => {
            const roomId = gameState.currentRoomId;
            update(ref(db, `whois_room/${roomId}`), { status: 'voting' });
        },

        votePlayer: async (targetId) => {
            const roomId = gameState.currentRoomId;
            const myId = gameState.user.id;
            
            const myRef = ref(db, `whois_room/${roomId}/players/${myId}`);
            await update(myRef, { voteTarget: targetId });
        },

        endVoting: async () => {
            const roomId = gameState.currentRoomId;
            
            const configSnapshot = await get(child(ref(db), `whois_room/${roomId}/config`));
            const config = configSnapshot.val();
            const civWinScore = (config.scoreSettings && config.scoreSettings.civ) ? parseInt(config.scoreSettings.civ) : 10;
            const spyWinScore = (config.scoreSettings && config.scoreSettings.spy) ? parseInt(config.scoreSettings.spy) : 20;

            onValue(ref(db, `whois_room/${roomId}/players`), async (snapshot) => {
                const players = snapshot.val();
                if(!players) return;

                const voteCounts = {};
                let maxVotes = -1;
                let eliminatedId = null;
                let isTie = false;

                Object.values(players).forEach(p => {
                    if (p.status === 'alive' && p.voteTarget) {
                        const target = p.voteTarget;
                        voteCounts[target] = (voteCounts[target] || 0) + 1;
                    }
                });

                Object.keys(voteCounts).forEach(pid => {
                    const count = voteCounts[pid];
                    if (count > maxVotes) {
                        maxVotes = count;
                        eliminatedId = pid;
                        isTie = false;
                    } else if (count === maxVotes) {
                        isTie = true;
                    }
                });

                let resultMessage = {};
                let nextStatus = 'playing'; 
                const updates = {};

                if (maxVotes === -1 || isTie) {
                    resultMessage = { name: isTie ? "å¹³ç¥¨" : "ç„¡äººæŠ•ç¥¨", role: "none", statusText: "ç„¡äººå‡ºå±€ï¼ŒéŠæˆ²ç¹¼çºŒ", type: "continue" };
                } else {
                    const deadPlayer = players[eliminatedId];
                    const deadRole = deadPlayer.role === 'spy' ? 'è‡¥åº•' : 'å¹³æ°‘';
                    
                    updates[`players/${eliminatedId}/status`] = 'dead';

                    let spyCount = 0;
                    let civCount = 0;
                    Object.keys(players).forEach(pid => {
                        let status = players[pid].status;
                        if(pid === eliminatedId) status = 'dead'; 
                        
                        if(status === 'alive') {
                            if (players[pid].role === 'spy') spyCount++;
                            else civCount++;
                        }
                    });

                    let winningTeam = null; 

                    if (spyCount === 0) {
                        resultMessage = { name: deadPlayer.name, role: deadPlayer.role, statusText: "ğŸ‰ å¹³æ°‘ç²å‹ï¼", type: "win" };
                        nextStatus = 'waiting'; 
                        winningTeam = 'civilian';
                    } else if (spyCount >= civCount) {
                        resultMessage = { name: deadPlayer.name, role: deadPlayer.role, statusText: "ğŸ˜ˆ è‡¥åº•ç²å‹ï¼", type: "win" };
                        nextStatus = 'waiting'; 
                        winningTeam = 'spy';
                    } else {
                        resultMessage = { name: deadPlayer.name, role: deadPlayer.role, statusText: "éŠæˆ²ç¹¼çºŒ", type: "continue" };
                        nextStatus = 'playing'; 
                    }

                    if (winningTeam) {
                        Object.keys(players).forEach(pid => {
                            const p = players[pid];
                            let currentScore = p.score || 0;
                            let addedScore = 0;
                            
                            let pStatus = p.status;
                            if (pid === eliminatedId) pStatus = 'dead';

                            if (winningTeam === 'spy') {
                                if (p.role === 'spy') {
                                    addedScore = spyWinScore;
                                }
                            } else if (winningTeam === 'civilian') {
                                if (p.role === 'civilian' && pStatus === 'alive') {
                                    addedScore = civWinScore;
                                }
                            }

                            if (addedScore > 0) {
                                updates[`players/${pid}/score`] = currentScore + addedScore;
                            }
                        });
                    }
                }

                resultMessage.nextGameStatus = nextStatus;

                await update(ref(db, `whois_room/${roomId}`), {
                    status: 'revealing',
                    result: resultMessage
                });
                
                Object.keys(players).forEach(pid => {
                    updates[`players/${pid}/voteTarget`] = null;
                });
                
                await update(ref(db, `whois_room/${roomId}`), updates);

            }, { onlyOnce: true });
        },

        closeOverlay: () => {
             document.getElementById('overlay-result').style.display = 'none';
             if (gameState.isHost) {
                 const roomId = gameState.currentRoomId;
                 const statusText = document.getElementById('res-game-status').innerText;
                 let nextState = 'playing';
                 if (statusText.includes("ç²å‹")) nextState = 'waiting';
                 update(ref(db, `whois_room/${roomId}`), { status: nextState });
             }
        },

        nextRound: () => window.app.startGame()
    };

    // --- UI æ¸²æŸ“é‚è¼¯ ---

    function renderRoomList(rooms) {
        const list = document.getElementById('room-list');
        list.innerHTML = "";
        if (!rooms) {
            list.innerHTML = "<p style='text-align:center; color:var(--text-muted);'>ç›®å‰æ²’æœ‰æˆ¿é–“</p>";
            return;
        }

        Object.keys(rooms).forEach(key => {
            const room = rooms[key];
            const pCount = room.players ? Object.keys(room.players).length : 0;
            const statusMap = { 'waiting': 'ç­‰å¾…ä¸­', 'playing': 'éŠæˆ²ä¸­', 'voting': 'æŠ•ç¥¨ä¸­', 'revealing': 'æ­æ›‰ä¸­' };
            const statusText = statusMap[room.status] || 'é€²è¡Œä¸­';
            const roomName = (room.config && room.config.roomName) ? room.config.roomName : `æˆ¿é–“ ${key}`;

            let adminControls = '';
            if (gameState.isAdmin) {
                adminControls = `<button class="admin-nuke-btn" onclick="app.adminForceDelete('${key}')">[X]</button>`;
            }

            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div>
                    <strong style="color:var(--text); font-size:16px;">${roomName}</strong> 
                    <span style="font-size:12px; color:var(--text-muted); margin-left:10px;">ID:${key}</span>
                    <br>
                    <div style="margin-top:6px;">
                        <span class="tag ${room.status === 'playing' ? 'host' : ''}">${statusText}</span>
                        <span class="tag" style="background:#334155;">${pCount}äºº</span>
                        ${adminControls}
                    </div>
                </div>
                <button class="small-btn secondary" style="width:auto; margin:0;" onclick="app.joinRoom('${key}')">åŠ å…¥</button>
            `;
            list.appendChild(div);
        });
    }

    function enterRoom(roomId) {
        window.app.switchScreen('screen-room');
        document.getElementById('room-id-display').innerText = `ID: ${roomId}`;
        document.getElementById('room-name-display').innerText = "è¼‰å…¥ä¸­...";

        const chatContainer = document.getElementById('chat-messages');
        chatContainer.innerHTML = '<div style="color:var(--text-muted); font-style:italic; margin-bottom:5px; text-align:center;">-- èŠå¤©å®¤å·²é€£æ¥ --</div>';

        onValue(ref(db, `whois_room/${roomId}`), (snapshot) => {
            const roomData = snapshot.val();
            if(!roomData) {
                alert("æˆ¿é–“å·²è§£æ•£");
                window.app.leaveRoom();
                return;
            }
            updateRoomUI(roomData);
        });

        const messagesRef = ref(db, `whois_room/${roomId}/messages`);
        onChildAdded(messagesRef, (data) => {
            const msg = data.val();
            renderChatMessage(msg);
        });
        
        const chatInput = document.getElementById('chat-input');
        chatInput.onkeypress = (e) => {
            if(e.key === 'Enter') window.app.sendChat();
        };
    }

    function renderChatMessage(msg) {
        const container = document.getElementById('chat-messages');
        const div = document.createElement('div');
        div.className = 'chat-msg';
        
        const isMe = msg.sender === gameState.user.name;
        if(isMe) {
            div.classList.add('is-me');
        }
        
        div.innerHTML = `<span class="chat-sender">${msg.sender}</span>${msg.text}`;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function updateRoomUI(roomData) {
        const players = roomData.players || {};
        const myId = gameState.user.id;
        const me = players[myId];
        
        if (roomData.config && roomData.config.roomName) {
            document.getElementById('room-name-display').innerText = roomData.config.roomName;
        }

        document.getElementById('player-count').innerText = Object.keys(players).length;
        
        document.getElementById('status-badge').innerText = 
            roomData.status === 'voting' ? 'æŠ•ç¥¨ä¸­' : (roomData.status === 'waiting' ? 'ç­‰å¾…ä¸­' : 'éŠæˆ²ä¸­');

        if (roomData.status === 'processing' && gameState.isHost) {
            assignRolesAndStart(roomData, Object.keys(players));
            return;
        }

        if (roomData.status === 'revealing' && roomData.result) {
            showResultOverlay(roomData.result);
        } else {
            document.getElementById('overlay-result').style.display = 'none';
        }

        const gameArea = document.getElementById('game-area');
        const btnStart = document.getElementById('btn-start');
        const btnRestart = document.getElementById('btn-restart');
        const ingameControls = document.getElementById('ingame-controls');
        const btnStartVote = document.getElementById('btn-start-vote');
        const btnEndVote = document.getElementById('btn-end-vote');
        const wordCard = document.getElementById('word-card');

        if (roomData.status === 'waiting') {
            gameArea.style.display = 'none';
            btnStart.style.display = 'block';
            ingameControls.style.display = 'none';
            btnRestart.style.display = 'none';
            gameState.wordVisible = false;
        } else {
            gameArea.style.display = 'block';
            btnStart.style.display = 'none';
            
            if (me && me.word) {
                const w = document.getElementById('my-word');
                if (gameState.wordVisible) {
                    w.innerText = me.word;
                    wordCard.classList.remove('hidden');
                    wordCard.classList.add('revealed');
                } else {
                    w.innerText = "???";
                    wordCard.classList.add('hidden');
                    wordCard.classList.remove('revealed');
                }
            }

            if (gameState.isHost) {
                if (roomData.status === 'voting') {
                    ingameControls.style.display = 'block';
                    btnStartVote.style.display = 'none';
                    btnEndVote.style.display = 'block';
                    btnRestart.style.display = 'none';
                } else if (roomData.status === 'playing') {
                    ingameControls.style.display = 'block';
                    btnStartVote.style.display = 'block';
                    btnEndVote.style.display = 'none';
                    btnRestart.style.display = 'none'; 
                } else {
                     ingameControls.style.display = 'none';
                     btnRestart.style.display = 'none';
                }
            } else {
                 ingameControls.style.display = 'none';
                 btnRestart.style.display = 'none';
            }
        }

        renderPlayerList(players, roomData.status, myId);
        document.getElementById('host-controls').style.display = gameState.isHost ? 'block' : 'none';
    }

    function renderPlayerList(players, status, myId) {
        const list = document.getElementById('player-list');
        list.innerHTML = "";
        
        const voteCounts = {};
        Object.values(players).forEach(p => {
            if(p.voteTarget) voteCounts[p.voteTarget] = (voteCounts[p.voteTarget] || 0) + 1;
        });

        const me = players[myId];
        const amIDead = me && me.status === 'dead';
        const myTarget = me ? me.voteTarget : null;

        Object.keys(players).forEach(pid => {
            const p = players[pid];
            const isMe = pid === myId;
            const votes = voteCounts[pid] || 0;
            const score = p.score || 0; 
            
            let secretReveal = '';
            
            const hasData = p.word && p.role;
            const isGameRunning = ['playing', 'voting', 'revealing'].includes(status);
            const isGameWaiting = status === 'waiting';
            
            let showIdentity = false;
            
            if (gameState.isAdmin && isGameRunning && hasData) showIdentity = true;
            if (isGameWaiting && hasData) showIdentity = true;

            if (showIdentity) {
                const isSpy = p.role === 'spy';
                const color = isSpy ? 'var(--danger)' : 'var(--success)';
                const roleName = isSpy ? 'è‡¥åº•' : 'å¹³æ°‘';
                
                secretReveal = `<div class="identity-reveal" style="color:${color}; border-color:${color};">
                    [${roleName}] ${p.word}
                </div>`;
            }

            const showHostBadge = p.isHost && (isMe || status === 'waiting');
            
            let scoreHtml = '';
            if (status === 'waiting') {
                scoreHtml = `<span class="tag score">Score: ${score}</span>`;
            }

            const div = document.createElement('div');
            div.className = `player-card ${isMe ? 'is-me' : ''} ${p.status === 'dead' ? 'dead' : ''}`;
            
            let actionHtml = '';

            if (status === 'voting' && p.status === 'alive') {
                if (!amIDead && !myTarget && !isMe) {
                    actionHtml = `<button class="vote-btn" onclick="app.votePlayer('${pid}')">æŠ•ç¥¨</button>`;
                } else if (myTarget === pid) {
                    actionHtml = `<span class="tag vote-count">å·²æŠ•</span>`;
                }
            }

            if (status === 'voting' || status === 'revealing') {
                if (votes > 0) {
                    actionHtml += `<span class="tag vote-count">${votes}ç¥¨</span>`;
                }
            }

            div.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <div style="display:flex; flex-direction:column;">
                        <div style="color:${p.status==='dead'?'#94a3b8':'inherit'}">
                            <strong style="font-weight:600;">${p.name}</strong>
                            ${showHostBadge ? '<span class="tag host">æˆ¿ä¸»</span>' : ''}
                            ${isMe ? '<span class="tag">æˆ‘</span>' : ''}
                            ${scoreHtml}
                        </div>
                        ${p.status === 'dead' ? '<span style="font-size:10px; color:var(--danger); font-weight:bold;">DEAD (å·²å‡ºå±€)</span>' : ''}
                        ${secretReveal}
                    </div>
                </div>
                <div style="display:flex; align-items:center;">
                    ${actionHtml}
                </div>
            `;
            list.appendChild(div);
        });
    }

    async function assignRolesAndStart(roomData, pIds) {
        const spyCount = roomData.config.spyCount;
        const total = pIds.length;
        
        let roles = Array(total).fill('civilian');
        for(let i=0; i<spyCount; i++) roles[i] = 'spy';
        
        for (let i = total - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [roles[i], roles[j]] = [roles[j], roles[i]];
        }

        const updates = {};
        pIds.forEach((pid, index) => {
            const role = roles[index];
            const word = role === 'spy' ? roomData.words.spy : roomData.words.civilian;
            updates[`whois_room/${gameState.currentRoomId}/players/${pid}/word`] = word;
            updates[`whois_room/${gameState.currentRoomId}/players/${pid}/role`] = role;
            updates[`whois_room/${gameState.currentRoomId}/players/${pid}/voteTarget`] = null; 
            updates[`whois_room/${gameState.currentRoomId}/players/${pid}/status`] = 'alive';
        });
        
        updates[`whois_room/${gameState.currentRoomId}/status`] = 'playing';
        await update(ref(db), updates);
    }

    function showResultOverlay(result) {
        const overlay = document.getElementById('overlay-result');
        const nameEl = document.getElementById('res-name');
        const roleEl = document.getElementById('res-role');
        const roleTextEl = document.getElementById('res-role-text');
        const statusEl = document.getElementById('res-game-status');

        nameEl.innerText = result.name;
        
        if (result.role === 'spy') {
            roleTextEl.innerText = "è‡¥åº• ğŸ˜ˆ";
            roleEl.className = "result-role spy";
        } else if (result.role === 'civilian') {
            roleTextEl.innerText = "å¹³æ°‘ ğŸ˜‡";
            roleEl.className = "result-role civilian";
        } else {
            roleTextEl.innerText = "";
            roleEl.className = "result-role";
        }

        statusEl.innerText = result.statusText;
        if(result.type === 'win') {
            statusEl.style.borderColor = 'var(--warning)';
            statusEl.style.color = 'var(--warning)';
        } else {
            statusEl.style.borderColor = '#475569';
            statusEl.style.color = '#cbd5e1';
        }

        overlay.style.display = 'flex';
    }

    document.getElementById('word-card').addEventListener('click', () => {
        gameState.wordVisible = !gameState.wordVisible;
        const w = document.getElementById('my-word');
        const card = document.getElementById('word-card');
        
        if(!gameState.wordVisible) {
             w.innerText = "???";
             card.classList.add('hidden');
             card.classList.remove('revealed');
        } else {
             w.innerText = "..."; 
             card.classList.remove('hidden');
             card.classList.add('revealed');
             
             const roomId = gameState.currentRoomId;
             if(roomId) {
                 get(child(ref(db), `whois_room/${roomId}`)).then((snap) => {
                     if(snap.exists()) updateRoomUI(snap.val());
                 });
             }
        }
    });

</script>
</body>
</html>